use std::{
    any::Any,
    cell::{Ref, RefCell, RefMut},
    fmt::Debug,
    rc::Rc,
};

use owning_ref::{OwningRef, OwningRefMut};

use super::{DepResult, DependencyCalculationContext, ItemDefinition};
use crate::{
    environment::{
        discover_equality::{DeqPriority, DeqResult, DeqSide, Equal},
        invariants::{InvariantSet, InvariantSetPtr},
        CheckResult, Environment,
    },
    item::{
        resolvable::{BoxedResolvable, DUnresolved, Resolvable},
        structt::CPopulatedStruct,
        substitution::Substitutions,
        variable::{CVariable, VariableId},
    },
    scope::Scope,
    shared::{AnyEq, Id, Pool},
};

pub type ItemPtr = Rc<RefCell<Item>>;

pub trait ItemPtrExtensions {
    fn is_same_instance_as(&self, other: &Self) -> bool;
    /// Returns a new pointer to the same object that self points to.
    fn ptr_clone(&self) -> Self;
    fn get_dependencies(&self) -> DepResult;
    fn downcast_definition<D: ItemDefinition>(&self) -> Option<OwningRef<Ref<Item>, D>>;
    fn downcast_definition_mut<D: ItemDefinition>(&self) -> Option<OwningRefMut<RefMut<Item>, D>>;
    fn is_unresolved(&self) -> bool;
}

impl ItemPtrExtensions for ItemPtr {
    fn is_same_instance_as(&self, other: &Self) -> bool {
        self.as_ptr() == other.as_ptr()
    }

    fn ptr_clone(&self) -> Self {
        Rc::clone(self)
    }

    fn get_dependencies(&self) -> DepResult {
        let ctx = DependencyCalculationContext::new();
        ctx.get_dependencies(self)
    }

    fn downcast_definition<D: ItemDefinition>(&self) -> Option<OwningRef<Ref<Item>, D>> {
        OwningRef::new(self.borrow())
            .try_map(|this| this.downcast_definition().ok_or(()))
            .ok()
    }

    fn downcast_definition_mut<D: ItemDefinition>(&self) -> Option<OwningRefMut<RefMut<Item>, D>> {
        OwningRef::new(self.borrow_mut())
            .try_map(|this| this.downcast_definition_mut().ok_or(()))
            .ok()
    }

    fn is_unresolved(&self) -> bool {
        self.borrow().is_unresolved()
    }
}

#[derive(Debug)]
pub struct Item {
    pub definition: Box<dyn ItemDefinition>,
    pub invariants: Option<InvariantSetPtr>,
    pub scope: Box<dyn Scope>,
    /// A dex that, when a value is plugged in for its first dependency, will
    /// evaluate to true if and only if the plugged in value could have been
    /// generated by this construct.
    pub from_dex: Option<ItemPtr>,
    pub name: Option<String>,
}

impl Item {
    pub fn downcast_definition<D: ItemDefinition>(&self) -> Option<&D> {
        (&*self.definition as &dyn Any).downcast_ref()
    }

    pub fn downcast_definition_mut<D: ItemDefinition>(&mut self) -> Option<&D> {
        (&*self.definition as &dyn Any).downcast_mut()
    }

    pub fn is_unresolved(&self) -> bool {
        self.downcast_definition::<DUnresolved>().is_some()
    }
}
