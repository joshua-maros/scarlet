use std::{any::Any, fmt::Debug};

use super::{
    structt::CPopulatedStruct,
    substitution::Substitutions,
    variable::{CVariable, VariableId},
};
use crate::{
    environment::{
        dependencies::DepResult,
        discover_equality::{DeqPriority, DeqResult, DeqSide, Equal},
        invariants::{InvariantSet, InvariantSetId},
        CheckResult, Environment,
    },
    resolvable::{BoxedResolvable, Resolvable},
    scope::Scope,
    shared::{AnyEq, Id, Pool},
};

#[derive(Debug)]
pub enum ItemDefinition {
    Other(ItemId),
    Resolved(BoxedConstruct),
    Placeholder,
}

impl ItemDefinition {
    pub fn is_placeholder(&self) -> bool {
        match self {
            Self::Placeholder => true,
            _ => false,
        }
    }

    pub fn as_other(&self) -> Option<ItemId> {
        match self {
            &Self::Other(con) => Some(con),
            _ => None,
        }
    }

    pub fn as_resolved(&self) -> Option<&BoxedConstruct> {
        match self {
            Self::Resolved(con) => Some(con),
            _ => None,
        }
    }
}

impl<'x> From<Box<dyn Construct>> for ItemDefinition {
    fn from(input: Box<dyn Construct>) -> Self {
        Self::Resolved(input)
    }
}

impl<'a, 'x> From<&'a ItemId> for ItemDefinition {
    fn from(input: &'a ItemId) -> Self {
        Self::Other(*input)
    }
}

impl<'x> From<ItemId> for ItemDefinition {
    fn from(input: ItemId) -> Self {
        Self::Other(input)
    }
}

#[derive(Debug)]
pub struct Item<'x> {
    pub definition: ItemDefinition,
    pub reduced: ItemDefinition,
    pub unresolved: Option<Box<dyn Resolvable<'x> + 'x>>,
    pub invariants: Option<InvariantSetId>,
    pub scope: Box<dyn Scope>,
    /// A dex that, when a value is plugged in for its first dependency, will
    /// evaluate to true if and only if the plugged in value could have been
    /// generated by this construct.
    pub from_dex: Option<ItemId>,
    pub name: Option<String>,
}

impl<'x> Item<'x> {
    pub fn is_unresolved(&self) -> bool {
        self.unresolved.is_some()
    }
}

pub type ItemPool<'x> = Pool<Item<'x>, 'I'>;
pub type ItemId = Id<'I'>;

pub type GenInvResult = InvariantSetId;

pub type BoxedConstruct = Box<dyn Construct>;
pub trait Construct: Any + Debug + AnyEq {
    fn dyn_clone(&self) -> Box<dyn Construct>;

    #[allow(unused_variables)]
    fn check<'x>(
        &self,
        env: &mut Environment<'x>,
        this: ItemId,
        scope: Box<dyn Scope>,
    ) -> CheckResult {
        Ok(())
    }

    fn contents<'x>(&self) -> Vec<ItemId> {
        vec![]
    }

    fn get_dependencies<'x>(&self, env: &mut Environment<'x>) -> DepResult;

    #[allow(unused_variables)]
    fn generated_invariants<'x>(&self, this: ItemId, env: &mut Environment<'x>) -> GenInvResult {
        env.push_invariant_set(InvariantSet::new_empty(this))
    }

    #[allow(unused_variables)]
    fn dereference(
        &self,
        env: &mut Environment,
    ) -> Option<(ItemId, Option<&Substitutions>, Option<Vec<ItemId>>)> {
        None
    }

    #[allow(unused_variables)]
    fn discover_equality<'x>(
        &self,
        env: &mut Environment<'x>,
        self_subs: Vec<&Substitutions>,
        other_id: ItemId,
        other: &dyn Construct,
        other_subs: Vec<&Substitutions>,
        limit: u32,
    ) -> DeqResult {
        Ok(Equal::Unknown)
    }

    fn as_def<'x>(&self) -> ItemDefinition {
        ItemDefinition::Resolved(self.dyn_clone())
    }
}

pub fn downcast_construct<T: Construct>(from: &dyn Construct) -> Option<&T> {
    (from as &dyn Any).downcast_ref()
}

pub fn downcast_boxed_construct<T: Construct>(from: Box<dyn Construct>) -> Option<T> {
    (from as Box<dyn Any>).downcast().ok().map(|b| *b)
}

pub fn as_struct(from: &dyn Construct) -> Option<&CPopulatedStruct> {
    downcast_construct(from)
}

pub fn as_variable(from: &dyn Construct) -> Option<&CVariable> {
    downcast_construct(from)
}

#[macro_export]
macro_rules! impl_any_eq_for_construct {
    ($ConstructName:ident) => {
        impl crate::shared::AnyEq for $ConstructName {
            fn eq(&self, other: &dyn crate::shared::AnyEq) -> bool {
                (other as &dyn std::any::Any)
                    .downcast_ref::<Self>()
                    .map(|x| self == x)
                    .unwrap_or(false)
            }
        }
    };
}
